<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>nonholo_control: src/target_reached_detection.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nonholo_control
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">target_reached_detection.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;ros/ros.h&quot;</code><br />
<code>#include &quot;std_msgs/Empty.h&quot;</code><br />
<code>#include &quot;std_srvs/Empty.h&quot;</code><br />
<code>#include &quot;actionlib_msgs/GoalStatusArray.h&quot;</code><br />
<code>#include &quot;move_base_msgs/MoveBaseActionGoal.h&quot;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;condition_variable&gt;</code><br />
<code>#include &lt;ros/callback_queue.h&gt;</code><br />
<code>#include &lt;thread&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for target_reached_detection.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="target__reached__detection_8cpp__incl.png" border="0" usemap="#src_2target__reached__detection_8cpp" alt=""/></div>
<map name="src_2target__reached__detection_8cpp" id="src_2target__reached__detection_8cpp">
</map>
</div>
</div>
<p><a href="target__reached__detection_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aac8de2be6952997c252a2a1cfbff2c0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#aac8de2be6952997c252a2a1cfbff2c0f">bugReachedCllbck</a> (std_srvs::Empty::Request &amp;req, std_srvs::Empty::Response &amp;res)</td></tr>
<tr class="separator:aac8de2be6952997c252a2a1cfbff2c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264fba927b5645fcf55bb56960bdd10a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#a264fba927b5645fcf55bb56960bdd10a">moveStatusCllbck</a> (const actionlib_msgs::GoalStatusArray::ConstPtr &amp;status_msg)</td></tr>
<tr class="separator:a264fba927b5645fcf55bb56960bdd10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4e27bb78f1fbfe925a71df5f24adcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#abd4e27bb78f1fbfe925a71df5f24adcf">moveGoalCllbck</a> (const move_base_msgs::MoveBaseActionGoal::ConstPtr &amp;move_msg)</td></tr>
<tr class="separator:abd4e27bb78f1fbfe925a71df5f24adcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1b629d7b148bc55cb3dd4cc3dde9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#aac1b629d7b148bc55cb3dd4cc3dde9e2">targetReachedCllbck</a> (const std_msgs::Empty::ConstPtr &amp;empty)</td></tr>
<tr class="separator:aac1b629d7b148bc55cb3dd4cc3dde9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab1303794238b69a8edb1c018191fafda"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#ab1303794238b69a8edb1c018191fafda">cv_plan</a></td></tr>
<tr class="separator:ab1303794238b69a8edb1c018191fafda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07a8449c8543cc31ab51d64a6e403eb"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#af07a8449c8543cc31ab51d64a6e403eb">mux_plan</a></td></tr>
<tr class="separator:af07a8449c8543cc31ab51d64a6e403eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4146a0218e7cf0e5037a8bbb7e993d74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#a4146a0218e7cf0e5037a8bbb7e993d74">is_bug_plan</a> = false</td></tr>
<tr class="separator:a4146a0218e7cf0e5037a8bbb7e993d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7487366daa84ade49239f344d482497"><td class="memItemLeft" align="right" valign="top">std_msgs::Empty&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#ad7487366daa84ade49239f344d482497">empty_msg</a></td></tr>
<tr class="separator:ad7487366daa84ade49239f344d482497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ff69735018017035e1aa238b704ed9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#a39ff69735018017035e1aa238b704ed9">target_reached</a> = true</td></tr>
<tr class="separator:a39ff69735018017035e1aa238b704ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350594df3e8f6948c8462edfd41ce086"><td class="memItemLeft" align="right" valign="top">ros::Publisher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#a350594df3e8f6948c8462edfd41ce086">pub</a></td></tr>
<tr class="separator:a350594df3e8f6948c8462edfd41ce086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acc03bbbf2ad7ec37de758eac1f1e63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="target__reached__detection_8cpp.html#a0acc03bbbf2ad7ec37de758eac1f1e63">wall_follow_active</a></td></tr>
<tr class="separator:a0acc03bbbf2ad7ec37de758eac1f1e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aac8de2be6952997c252a2a1cfbff2c0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bugReachedCllbck </td>
          <td>(</td>
          <td class="paramtype">std_srvs::Empty::Request &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std_srvs::Empty::Response &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to a call on service '/redirect_bug_user_interface'</p>
<p>The script 'bug_m' calls the service 'user_interface', remapped to this service, when the target position is reached in order to receive a new one. Originally another node would ask that input to the user, but here it's intercepted in order to detect when a target results reached when using the bug0 planner. Note that the service is empty, the important thing is just that a call is received, no exchange of data. Notice the usage of a con</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>(std_srvs::Empty::Request &amp;): request field of the service (empty, unused); </td></tr>
    <tr><td class="paramname">res</td><td>(std_srvs::Empty::Response &amp;): response field of the service, (empty, unused);</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">success</td><td>(bool): 'true' by default (unused); </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00089">89</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00203">203</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd4e27bb78f1fbfe925a71df5f24adcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveGoalCllbck </td>
          <td>(</td>
          <td class="paramtype">const move_base_msgs::MoveBaseActionGoal::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>move_msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to a message on topic '/move_base/goal'</p>
<p>Once a new goal is issued the node is made susceptible again to messages or service calls interpretable as 'target reached'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move_msg</td><td>(const move_base_msgs::MoveBaseActionGoal::ConstPtr&amp;): goal message (unused); </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00170">170</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a264fba927b5645fcf55bb56960bdd10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveStatusCllbck </td>
          <td>(</td>
          <td class="paramtype">const actionlib_msgs::GoalStatusArray::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>status_msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to a message on topic '/move_base/status'</p>
<p>The message contains various information, among which is the current status of the robot with respect to the target position. The status ID = 3 corresponds to "target reached". If such status is reached when the current planning algorithm is "move_base" a message on topic '/target_reached' is published. Notice that, due to the periodic nature of this callback, a flag is here set, making this node react only to the first message stating a target reached received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_msg</td><td>(const actionlib_msgs::GoalStatusArray::ConstPtr&amp;): status message, the actual status ID is contained in field 'status' inside the last element of the 'status_list' field of the message, </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00141">141</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac1b629d7b148bc55cb3dd4cc3dde9e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void targetReachedCllbck </td>
          <td>(</td>
          <td class="paramtype">const std_msgs::Empty::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>empty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to a message on topic '/target_reached'</p>
<p>Once a message from that topic is received the node is made unsusceptible to a new message informing of the target being reached (until a new goal is issued, see 'moveGoalCllbck' function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty</td><td>(const std_msgs::Empty::ConstPtr&amp;): (empty, unused); </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00197">197</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ab1303794238b69a8edb1c018191fafda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable cv_plan</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This code detects whenever a target results reached by any of the algorithms used. To do that it looks at the status of the 'move_base' planning (if present) and at the service requeste by the 'bug_m' (originally for its UI, now redirected). This implements a new node handle, with a callback queue dedicated to deal with services requests made from bug_m at the instant it reaches a target. While, in the original algorithm, it waited until a new user input by directly calling the user interface, here that solution is not feasible, since the UI is called by the "mainframe" algorithm. But what this node can know is when a new goal is established, since it gets published on 'move_base/goal'. The callback to the redirected user_interface service from bug_m is thus stopped (using mutexes and conditional variables) until a new move_base/goal message arrives (which sets the global variable target_reacheed to 'false'). However, if we were to use the same callback queue for all incoming messages and requests, this wait on the condvar would stop the spinner from serving other messages (thus preventing the variable to ever change, deadlocking the system). This is the reason why a new spinner thread is created to uniquely serve the '/redirect_bug_user_interface' service requests, so that it can be blocked without interfering with all other callbacks.Conditional variable regulating the reply to the service called from bug_m </p>

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00047">47</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7487366daa84ade49239f344d482497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std_msgs::Empty empty_msg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00051">51</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4146a0218e7cf0e5037a8bbb7e993d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_bug_plan = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boolean expressing the condition, 'true' when the plan is "bug0", 'false' else </p>

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00049">49</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af07a8449c8543cc31ab51d64a6e403eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex mux_plan</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutex protecting the boolean the conditional variable is tested on </p>

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00048">48</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a350594df3e8f6948c8462edfd41ce086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ros::Publisher pub</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00053">53</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39ff69735018017035e1aa238b704ed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool target_reached = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00052">52</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0acc03bbbf2ad7ec37de758eac1f1e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wall_follow_active</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global value denoting if the robot is currently in wall following mode, in order to allow (or prevent) 'bug_m' node to control go_to_point_switch and wall_follower_switch </p>

<p>Definition at line <a class="el" href="target__reached__detection_8cpp_source.html#l00056">56</a> of file <a class="el" href="target__reached__detection_8cpp_source.html">target_reached_detection.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
